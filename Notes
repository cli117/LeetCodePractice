1. Array操作时，考虑two pointer方法，详见 <11>, <15>.
2. 对LinkedList操作时，考虑两个指针以省去一次遍历，详见<19> 还有很讨巧的快慢指针做法详见<141> <160>
3. Backtracking的时间复杂度：O(b^d)，b是每一次做决定可以选择的选项数量，d是决策树的深度。最后一层会有b^d个node。
4. In Java programming, Java Priority Queue is implemented using Heap Data Structures and Heap has O(log(n))
time complexity to insert and delete element. 多个list之间比较的时候，可以建立长度为k的priority queue而不是直接比较。
可将时间复杂度从O(k)降低到O(logk)。详见<23> 可使用comparator或者讲排序的对象implement comparable两种方式。
5. The next lexicographic permutation of the given list of numbers: 在给定int array中找出所有排序可能中比当前排序
大的最小数。（如将所有permutation都排序好，找到当前顺序的下一个大的顺序）。详见<31>
6. RotatedSortedArray, 将array按大小画图，将mid和right的关系，mid和target，right和target的大小分情况讨论。
注意：当left和right需要update并且跟mid一样的时候（由于进位），将mid进行++或者--以进行一次更新。
7. MergeIntervals, 客制的class可以implement Comparable<CustomClass>并override compareTo来使用
Collections.sort(List<CustomClass>)来按需求sort
8. DP最终要的点是想到dp[i] 和 dp[i-1]的关系 或 在2Darray中 如何从前面的已算出的求出dp[i][j] 以及各位置初始值
典型的一种是某个status可以由多个其他status达到，那么新的dp entry就由前面的dp entry相加 详见<70>。
9. dp中很多2D array比较好想，但是很多可以用1D array就可以达到需求 详见<53> <62>.
10.* Stack可以解决计算最小面积的问题。维护方式见<84>.
11. Binary tree的多种遍历方法，详见<94>
12. 使用Set来检查一组数据中是否包含某一个：O(1)
13. 考虑bitwise运算，相同的数字使用xor(^) 运算可得出0。在136题中可使用bitwise运算迅速出结果。
14. 递归使用栈来记忆，故递归n次则的空间复杂度至少为O(n)
15. Java遍历Map for(Map.Entry<Integer, Integer> entry : counts.entrySet())
16. DP: 设计动态规划的三个步骤
        将问题分解成最优子问题；
        用递归的方式将问题表述成最优子问题的解；
        自底向上的将递归转化成迭代；（递归是自顶向下）; 所以空间复杂度会变为O(1)
        最优子问题
        对于连续的 nn 栋房子：H~1~,H~2~,H~3~......H~n~H 1 ,H 2 ,H 3 ......H n ，小偷挑选要偷的房子，且不能偷相邻的两栋房子，方案无非两种：
        方案一：挑选的房子中包含最后一栋；
        方案二：挑选的房子中不包含最后一栋；
        获得的最大收益的最终方案，一定在这两种方案中产生，用代码表述就是：
        最优结果 = Math.max(方案一最优结果，方案二最优结果)
        详见 <198>

17. 拓扑排序，检测有向图是否存在环。如无 可算出一个符合条件的path。方法分为DFS, BFS。详见 <207>
18. 新数据结构：Trie (we pronounce "try") or prefix tree is a tree data structure, which is used for retrieval of a
key in adataset of strings. There are various applications of this very efficient data structure such as :
    i) Autocomplete ii) Spell Checker iii) IP routing ...
19. deque, double ended queue 双端队列，在头部尾部插入删除都是O（1），详见 <239>
20. LinkedList用快慢指针法检测是否有环。找入口时，将慢指针结果和一个初始化指针一同遍历LL，相遇处即为环入口。(a为非环长，b为环长)
（t(fast) = t(slow) + nb, t(fast) = 2 * t(slow), t(slow) = nb, 而a+nb就会到达入口，所以再给slow+a即为结果）<142> <287>
21. *重要！ heap由int[] 实现，最大最小堆根据要求选择，不使用指针对象等节约空间。一个node的parent的index为 (n-1)/2。java中
的PriorityQueue实现了最小堆，堆顶是最小值。通过override comparator或者使用lambda表达式可以转变为最大堆。详见<295>
22. 在serialize和deserialize中，虽然例子中给出的中间结果是BFS，但BFS出的较难重构新tree，故使用递归法一路向左再向右得到
serialize后的结果再用递归重构。详见 <297>
23. 频繁使用String += 操作的话 应该使用StringBuilder来append
24. <300> 应该能想出来的 再多看看 <301> nice backtrack，基本为<22>的变种
25. 根据状态做DP。中文309题 第一个答案
26. DP: Top-down 解出递推公式后，top-down是用recursion将大问题变成小问题，并把小问题用recursion解决，然后在method里用if
给base case赋值。而bottom-up用array，将base case的值直接赋给array，再通过递推公式算出结果。直接返回dp array的最后一个。
相似的，普通recursion直接return当前循环的结果+下一个call结果，栈中一直存着中间结果，会导致爆栈。而tail recursion将结果存为
一个变量 在recursion中传递，大大减少内存用量和爆栈问题。
27. Java中的位操作 各种奇技淫巧 详见 <191> 中的题解， n &= (n-1) 可以去掉最后一个bit的1
重要：判断奇偶性用i&1来判断 既和1做和运算 如果得1则为奇，得0为偶  // x / 2 is x >> 1 and x % 2 is x & 1
https://www.cnblogs.com/hapjin/p/5839797.html

28. 将int[] linkedlist，也就是一串数字对，转化成二维数组：output.toArray(new int[n][2]);
29. 如果dp只对自己上面的元素有依赖，则可以使用一维数组。上方和左上，一维数组倒序（只有倒序才能保证用到的是旧的上一行的数据，不然
新更新的数据会覆盖掉旧的，导致错误。）同理，如果上方和右上，则可正常使用一维数组正序。
30. 中文<312> 第二个答案
31. 在树的递归中，可以传递一个array来存储到目前为止这条path的所有元素。每个recursion中array不一样，所以表达的path也不一样。
然后可以对path进行操作来达到目的。通常需要一个int来记录当前path的长度。
32. 双指针法的sliding window比一个长度固定的window slide效率高：会略过很多不用检查的window。检查重复方法详见<438>
33. 数组求和的问题常用dp，二维数组[i][j] 其中i代表前i个元素，j代表合为j。根据情况求出递推公式，再分析能不能使用一维数组节约
空间。
34. 记得使用sort的方法得到基础的答案。
35. 反向sort： Collections.sort(collection, Collections.reverseOrder());
              Arrays.sort(array, Collections.reverseOrder());
36. 比大小的时候记得尝试stack，stack中常存的是index。取值比较时使用nums[stack.peek()]


看过答案以后还不会的:
<84> <85>(85是n个84题合起来，n为行数)
<41> 数组操作中将一个值放到想要放的位置用交换，不需要链式操作。而换过来的值需要重新考虑。但如果两个交换值相等，不做交换。
<39>(backtrack剪枝)
<34> BS
<32> stack/DP
<31> 词典序
<3> sliding window


*** 双指针法可以找到链表中点
*** Top-down 都是recursion，bottom-up是直接从小问题往上走
*** 找在n为长，元素为1~n的数组中找重复数字，可以将数组看作LL，找环的入口
*** DP是状态转移，一个状态由一个或多个 有效 的状态计算而成。当处理删除无效括号的一类问题中，有效的状态可能从非有效的状态
转移而来。故不能使用DP，而是从backtrack入手再进行优化
*** 检测括号是否合法，遍历 一旦#left - #right 为负直接不合法。最后返回 #left - #right == 0
*** BFS在删除括号问题中，指不管遇到‘(’还是‘)’，都尝试删除。DFS是查找不合法的是‘(’还是‘)’并一直删除同一个。
*** Sliding window 通常是两个变量l和r，根据要求缩放。一般是r向后推，到不符合条件以后l向后推，r重新开始。
*** 如果dp的array是Boolean array，很可能需要分情况讨论并且用逻辑连接符来计算新结果。
*** 合并两个sorted array，可以从头开始（ptr从0开始，小的往头放）。或者从尾开始（ptr从length - 1开始，大的往尾放）
*** 计算mid时， mid = (lo + hi) / 2; 会overflow. 用 int mid = lo + (hi - lo) / 2  来代替。